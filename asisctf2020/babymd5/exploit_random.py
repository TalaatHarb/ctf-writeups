from pwn import *
from Crypto.Hash import *
import random, string

def babymd5(m, n, x_head, y_head, x, y):
    for _ in range(m):
        xhash = MD5.new(x.encode('utf-8')).hexdigest()
        x = xhash
    for _ in range(n):
        yhash = MD5.new(y.encode('utf-8')).hexdigest()
        y = yhash
    if xhash == yhash:
        return True
    return False

host = '66.172.10.203'
port = 2570

p = remote(host, port)

data = p.recvline().decode('utf-8')
print(data)

parts = data.split(' ')

if parts[8].startswith('sha'):
    hash_fun = int(parts[8][3:parts[8].index('(')])
else:
    hash_fun = 5

hash = parts[10]
length = int(parts[14])

if hash_fun == 1:
    f = lambda x : SHA1.new(x.encode('utf-8')).hexdigest()
if hash_fun == 224:
    f = lambda x : SHA224.new(x.encode('utf-8')).hexdigest()
if hash_fun == 256:
    f = lambda x : SHA256.new(x.encode('utf-8')).hexdigest()
if hash_fun == 384:
    f = lambda x : SHA384.new(x.encode('utf-8')).hexdigest()
if hash_fun == 512:
    f = lambda x : SHA512.new(x.encode('utf-8')).hexdigest()
if hash_fun == 5:
    f = lambda x :  MD5.new(x.encode('utf-8')).hexdigest()

charachter_space = string.ascii_letters + string.digits + string.punctuation

new_hash_seg = ''
counter = 0
while new_hash_seg != hash:
    new_str = ''.join(random.choice(charachter_space) for _ in range(length))
    new_hash_seg = f(new_str)[-6:]
    if counter % 10000 == 0:
        print('Attempt(',hash,'):', counter, ', new_str =', new_str, ', new_hash_seg =', new_hash_seg)
    counter = counter + 1

p.sendline(new_str)
print('string =', new_str)
print('hash =', f(new_str))

print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))


p.sendline('C')
conditions = p.recvline().decode('utf-8')
print(conditions)
#| (m, n, x_head, y_head) = (233, 207, 'aqY', 'dead')

parts = conditions.split(' ')
m = int(parts[6][1:-1])
n = int(parts[7][0:-1])
x_head = parts[8][1:-2]
y_head = 'dead'

print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))
print(p.recvline().decode('utf-8'))

found = False
length = 32
counter = 0
while not found:
    possible_x = x_head + ''.join(random.choice(charachter_space) for _ in range(length))
    x_hash = possible_x
    for _ in range(m-n):
        x_hash = MD5.new(x_hash.encode('utf-8')).hexdigest()
    if x_hash.startswith(y_head):
        x = possible_x
        y = x_hash
        print('x =', x, ', y =', y)
        found = babymd5(m, n, x_head, y_head, x, y)
        break
    if counter % 10000 == 0:
        print('Attempt:', counter, ', x =', possible_x, ', x_hash =', x_hash)
    if counter % 1000000 == 0:
        p.sendline('C')
    counter = counter + 1

p.sendline('R')
p.sendline(x)
p.sendline(y)



p.interactive()
p.close()
